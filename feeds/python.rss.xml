<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dv 名字很難念</title><link>/</link><description></description><atom:link href="/feeds/python.rss.xml" rel="self"></atom:link><lastBuildDate>Fri, 26 Sep 2014 12:27:00 +0800</lastBuildDate><item><title>Generational Garbage Collection for SpiderMonkey</title><link>/posts/2014/09/ggc-spidermonkey/</link><description>&lt;p&gt;原文章 : &lt;a class="reference external" href="https://hacks.mozilla.org/2014/09/generational-garbage-collection-in-firefox/"&gt;Generational Garbage Collection in Firefox&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天看到上面那篇 SpiderMonkey 的 Generational Garbage Collection 的文章，
就讀一讀理解一下並做些紀錄&lt;/p&gt;
&lt;div class="section" id="generational-garbage-collection"&gt;
&lt;h2&gt;Generational garbage collection&lt;/h2&gt;
&lt;p&gt;Generational garbage collection 的核心觀念就是 &amp;quot;大多數的物件的生命都很短&amp;quot;，
所以就修改原本的 GC 設計，依照不同的存在時間有不同的處理方式，
對於 Tracing 的 GC 會需要去掃過物件來檢查是否有物件已經成為 Garbage，
當程式會製造出大量的物件時，檢查的時間就會上升，這時如果用已經存在的時間來區分，
而做不同的處理方式時，多數的短期物件就可以更快的被回收，也不必頻繁檢查會長期存在的物件。&lt;/p&gt;
&lt;p&gt;原文章裡的 SpiderMonkey 利用了這種方式來讓 temporary objects 的 penalty 下降&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="nursery-tenured"&gt;
&lt;h2&gt;Nursery &amp;amp; Tenured&lt;/h2&gt;
&lt;p&gt;多數的 objects 都會 allocate 到一個叫做 Nursery 的 memory region，
當 Nursery 滿的時候，只檢查 Nursery 裡的 objects，此時多數的 short-lived temporary objects 就會被清掉，
而這樣的檢查相對於原本 (檢查全部的 objects) 也來的快&lt;/p&gt;
&lt;p&gt;此時，依然存活的 objects 就會被放到 Tenured region&lt;/p&gt;
&lt;p&gt;Tenured heap 仍然會回收 grabage，但是頻率會比 Nursery 來的低&lt;/p&gt;
&lt;p&gt;最終然會需要原整的 GC，但是頻率也會比 Nursery GC 來的低&lt;/p&gt;
&lt;p&gt;所以就分成下面這種情況&lt;/p&gt;
&lt;table border="1" class="table table-bordered docutils"&gt;
&lt;colgroup&gt;
&lt;col width="40%" /&gt;
&lt;col width="24%" /&gt;
&lt;col width="22%" /&gt;
&lt;col width="14%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;Garbage Collection&lt;/th&gt;
&lt;th class="head"&gt;Scan Place&lt;/th&gt;
&lt;th class="head"&gt;frequency&lt;/th&gt;
&lt;th class="head"&gt;speed&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;minor GCs&lt;/td&gt;
&lt;td&gt;Nursery&lt;/td&gt;
&lt;td&gt;high&lt;/td&gt;
&lt;td&gt;fast&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;major GCs&lt;/td&gt;
&lt;td&gt;full heap&lt;/td&gt;
&lt;td&gt;low&lt;/td&gt;
&lt;td&gt;slow&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table border="1" class="table table-bordered docutils"&gt;
&lt;colgroup&gt;
&lt;col width="68%" /&gt;
&lt;col width="32%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;memory region&lt;/th&gt;
&lt;th class="head"&gt;age&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;Nursery&lt;/td&gt;
&lt;td&gt;young&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Tenured&lt;/td&gt;
&lt;td&gt;old&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="problem"&gt;
&lt;h2&gt;Problem&lt;/h2&gt;
&lt;p&gt;Tenured object 裡面可能有指向 Nursery object 的資料
(Nursery objects 因為某些 Tenured objects 而持續 alive)&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;解法一&lt;/h3&gt;
&lt;p&gt;掃過整個 Tenured heap 來找出指到 Nursery objects 的 pointer，
但是這麼做的話就違背了 GGC 的設計本意，所以需要更 cheap 的解決方案&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;解法二&lt;/h3&gt;
&lt;p&gt;先注意到，在 heap graph 中 Tenured 指向 Nursery 的 edges 不會存在很久，
因為接下來 minor GC 就會把 Nursery 中的 survivors 移到 Tenured heap&lt;/p&gt;
&lt;p&gt;所以我們在意的是從上次 minor/major GC 後，有更動過的 Tenured objects，
而這些 objects 的數量相對來說就會比較少&lt;/p&gt;
&lt;p&gt;因此我們做的是在更動 Tenured objects 時，檢查是否有 Nursery pointers，
如果有的話就把這些 cross-generational edges 紀錄到 &lt;strong&gt;store buffer&lt;/strong&gt; ，
這樣的事情稱為 write barrier&lt;/p&gt;
&lt;p&gt;在 minor GC 時，我們就跑過一遍 store buffer 裡的資料並且把裡面的 Nursery objects 標記為存在&lt;/p&gt;
&lt;p&gt;(edge 的來源都需要被使用，因為當 Nursery objects 被標記為存在之後，將會移往 Tenured area，
所以原本的 Tenured (裡面有指向 Nursery 的 pointer) 也需要被 update&lt;/p&gt;
&lt;p&gt;minor GC 需要的執行時間決定於新 cross-generational edges 和 Nursery 裡的 objects 數量，
當然，追蹤 store buffer records 或是單純的檢查是否要新增 record 都會讓 normal heap access 有些許的效能損失，
所以某些 code 可能在 GGC 裡會變慢一些&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wdv4758h</dc:creator><pubDate>Fri, 26 Sep 2014 12:27:00 +0800</pubDate><guid>tag:,2014-09-26:posts/2014/09/ggc-spidermonkey/</guid><category>Python</category><category>gc</category></item><item><title>Python coding style</title><link>/posts/2014/09/python-coding-style/</link><description>&lt;ul class="simple"&gt;
&lt;li&gt;不能不提的 &lt;a class="reference external" href="http://legacy.python.org/dev/peps/pep-0008/"&gt;PEP8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://google-styleguide.googlecode.com/svn/trunk/pyguide.html"&gt;Google Python Style Guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wdv4758h</dc:creator><pubDate>Sat, 13 Sep 2014 15:20:00 +0800</pubDate><guid>tag:,2014-09-13:posts/2014/09/python-coding-style/</guid><category>Python</category></item><item><title>About Stackless Python</title><link>/posts/2014/02/stackless-python/</link><description>&lt;p&gt;Stackless Python 背後的由來以及現況 ~&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://stackoverflow.com/questions/588958/what-are-the-drawbacks-of-stackless-python/590412#590412"&gt;聽故事去&lt;/a&gt;&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wdv4758h</dc:creator><pubDate>Mon, 24 Feb 2014 19:44:00 +0800</pubDate><guid>tag:,2014-02-24:posts/2014/02/stackless-python/</guid><category>Python</category></item><item><title>Python - @wraps</title><link>/posts/2014/02/python-wraps/</link><description>&lt;p&gt;在這邊先假設看這篇文章的都知道 decorator&lt;/p&gt;
&lt;p&gt;在使用 decorator 時，若沒有經過處理，可能會造成 function 的 property 改變，例如:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;this is in test function&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;haha&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;this is in haha function&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;haha&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;haha&lt;/span&gt;

&lt;span class="nd"&gt;@test&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;func1&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;this is in func1&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;func1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__name__&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;,&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="n"&gt;func1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__doc__&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c"&gt;# OUTPUT :&lt;/span&gt;
&lt;span class="c"&gt;#   haha , this is in haha function&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到 func1 的 &lt;cite&gt;__name__&lt;/cite&gt; 和 &lt;cite&gt;__doc__&lt;/cite&gt; 都改變了，這通常不是我們想要的，還有可能在 debug 的時候造成麻煩&lt;/p&gt;
&lt;p&gt;因此 Python 有了 wraps 這個 decorator 去處理這個問題 (在 functools 裡)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;functools&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;wraps&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;this is in test function&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    &lt;span class="nd"&gt;@wraps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;haha&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;this is in haha function&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;haha&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;haha&lt;/span&gt;

&lt;span class="nd"&gt;@test&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;func1&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;this is in func1&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;func1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__name__&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;,&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;func1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__doc__&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c"&gt;# OUTPUT :&lt;/span&gt;
&lt;span class="c"&gt;#   func1 , this is in func1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，加上了 &amp;#64;wraps 後維持了 function 本來的 property ~&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wdv4758h</dc:creator><pubDate>Thu, 06 Feb 2014 11:30:00 +0800</pubDate><guid>tag:,2014-02-06:posts/2014/02/python-wraps/</guid><category>Python</category></item><item><title>初次使用 Pelican</title><link>/posts/2014/02/pelican/</link><description>&lt;p&gt;首先，什麼是 &lt;a class="reference external" href="http://docs.getpelican.com/en/"&gt;Pelican&lt;/a&gt; 呢？
Pelican 是個 Python 寫的靜態網站 generator，
你可以使用 Markdown, reStructuredText, AsciiDoc 等 markup language 作為撰寫的格式，
然後經由 Pelican 去生成靜態的網頁，經由這種方式，可以方便地使用你喜歡的文字編輯器去撰寫你的文章，
還可以結合 Version Control 去管理，
而由於生成的網頁是靜態的，所以可以放到 Github Pages 或者其他可以放置靜態網頁的地方去 Host，無疑是個很方便的模式。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;Pelican 初步設定&lt;/h2&gt;
&lt;/div&gt;
&lt;div class="section" id="theme"&gt;
&lt;h2&gt;Theme&lt;/h2&gt;
&lt;/div&gt;
&lt;div class="section" id="disqus-support"&gt;
&lt;h2&gt;Disqus Support&lt;/h2&gt;
&lt;p&gt;Pelican 要支援 Disqus 非常簡單，首先只要在你的 Disqus 新增好你的網站，獲得你的 Disqul url 後，
只要在你的 pelicanconf.py 裡新增 DISQUS_SITENAME = 'your-disqus-url' 即可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;DISQUS_SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;my-blog.disqus.com&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wdv4758h</dc:creator><pubDate>Sat, 01 Feb 2014 14:33:00 +0800</pubDate><guid>tag:,2014-02-01:posts/2014/02/pelican/</guid><category>pelican</category><category>Python</category></item></channel></rss>