<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Dv 名字很難念</title><link href="/" rel="alternate"></link><link href="/feeds/linux.atom.xml" rel="self"></link><id>/</id><updated>2015-01-21T13:12:00+08:00</updated><entry><title>[閱讀 &amp; 翻譯] Linux Input Ecosystem</title><link href="/posts/2015/01/linux-input-ecosystem/" rel="alternate"></link><updated>2015-01-21T13:12:00+08:00</updated><author><name>wdv4758h</name></author><id>tag:,2015-01-21:posts/2015/01/linux-input-ecosystem/</id><summary type="html">&lt;p&gt;以下內容翻譯自 &lt;a class="reference external" href="https://joeshaw.org/2010/10/01/681/"&gt;linux input ecosystem (2010), by joe shaw&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(還有我的幾張截圖 zzz)&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;目前 Linux kernel 的 input system 分成兩大塊，一個是 &lt;tt class="docutils literal"&gt;device driver&lt;/tt&gt; ，另一個是 &lt;tt class="docutils literal"&gt;event driver&lt;/tt&gt; 。
device driver 顯然地就是跟硬體溝通，
device driver 裡，大部分的 USB devices 都是由 &lt;tt class="docutils literal"&gt;usbhid driver&lt;/tt&gt; 負責。
event driver 負責的則是把 device driver 產生的 events 丟到 userspace，
目前這邊主要是由 &lt;tt class="docutils literal"&gt;evdev&lt;/tt&gt; 來完成，
evdev 會建立 &lt;tt class="docutils literal"&gt;character devices&lt;/tt&gt; (通常叫 &lt;tt class="docutils literal"&gt;/dev/input/eventN&lt;/tt&gt;) 並且用 &lt;tt class="docutils literal"&gt;struct input_event&lt;/tt&gt; 來溝通。&lt;/p&gt;
&lt;p&gt;要取得 evdev 的 devices 和 events 的資訊可以使用 &lt;tt class="docutils literal"&gt;evtest&lt;/tt&gt;&lt;/p&gt;
&lt;img alt="evtest &amp;amp; touchpad" src="/img/linux/evtest.png" /&gt;
&lt;p&gt;當一個 device 接上的時候，kernel 會為 device 在 &lt;tt class="docutils literal"&gt;sysfs&lt;/tt&gt; 建立一個 entry，
並且產生 hotplug event，該 event 會由 &lt;tt class="docutils literal"&gt;udev&lt;/tt&gt; 處理 (套一些 policy 和額外的 properties)，
然後在 &lt;tt class="docutils literal"&gt;/dev&lt;/tt&gt; 建立 device node，input devices 會套用 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;/lib/udev/rules.d/60-persistent-input.rules&lt;/span&gt;&lt;/tt&gt; 裡的 rules，
其中還會 run &lt;tt class="docutils literal"&gt;/lib/udev/input_id&lt;/tt&gt; tool 來從 sysfs node 取得 device 的 capabilities，
並且在 udev database 中設好環境變數 (例如: ID_INPUT_KEYBOARD, ID_INPUT_TOUCHPAD)。&lt;/p&gt;
&lt;p&gt;除了前面提的東西外，
X 也有 udev config backend 會在 startup 以及 hotplug devices 進來時運作 (為不同 input devices 去 queries udev)。
X 會看不同的 &lt;tt class="docutils literal"&gt;ID_INPUT_*&lt;/tt&gt; properties 來判斷目前是哪個 device (keyboad, mouse, touchpad, joystick, ...)，
這些資訊可以用於 &lt;tt class="docutils literal"&gt;xorg.conf.d&lt;/tt&gt; 裡面的 InputClass sections
(例如: MatchIsPointer, MatchIsTouchpad, MatchIsJoystick, ...)&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# xorg.conf.d/50-synaptics.conf

Section &amp;quot;InputClass&amp;quot;
    Identifier &amp;quot;touchpad catchall&amp;quot;
    Driver &amp;quot;synaptics&amp;quot;
    MatchIsTouchpad &amp;quot;on&amp;quot;
        Option &amp;quot;TapButton1&amp;quot;             &amp;quot;1&amp;quot;
        Option &amp;quot;TapButton2&amp;quot;             &amp;quot;2&amp;quot;
        Option &amp;quot;TapButton3&amp;quot;             &amp;quot;3&amp;quot;
        Option &amp;quot;VertEdgeScroll&amp;quot;         &amp;quot;1&amp;quot;
        Option &amp;quot;VertTwoFingerScroll&amp;quot;    &amp;quot;1&amp;quot;
        Option &amp;quot;VertScrollDelta&amp;quot;        &amp;quot;-58&amp;quot;
        Option &amp;quot;HorizEdgeScroll&amp;quot;        &amp;quot;1&amp;quot;
        Option &amp;quot;HorizTwoFingerScroll&amp;quot;   &amp;quot;1&amp;quot;
        Option &amp;quot;HorizScrollDelta&amp;quot;       &amp;quot;58&amp;quot;
        Option &amp;quot;CircularScrolling&amp;quot;      &amp;quot;1&amp;quot;
        Option &amp;quot;CircScrollTrigger&amp;quot;      &amp;quot;0&amp;quot;
        Option &amp;quot;CircScrollDelta&amp;quot;        &amp;quot;58&amp;quot;
        Option &amp;quot;EmulateTwoFingerMinZ&amp;quot;   &amp;quot;40&amp;quot;
        Option &amp;quot;EmulateTwoFingerMinW&amp;quot;   &amp;quot;8&amp;quot;
        Option &amp;quot;CoastingSpeed&amp;quot;          &amp;quot;0&amp;quot;
        Option &amp;quot;FingerLow&amp;quot;              &amp;quot;35&amp;quot;
        Option &amp;quot;FingerHigh&amp;quot;             &amp;quot;40&amp;quot;
EndSection
&lt;/pre&gt;
&lt;p&gt;Xorg 在 input devices 的 driver (handler) 的地方可以是 &lt;tt class="docutils literal"&gt;evdev&lt;/tt&gt; 、 &lt;tt class="docutils literal"&gt;synaptics&lt;/tt&gt; 、 &lt;tt class="docutils literal"&gt;joystick&lt;/tt&gt; 。&lt;/p&gt;
&lt;p&gt;Linux 在 evdev 裡有一個良好的 generic event interface，
所以只需要少量 drivers 就能跟硬體互動 (因為他們不走 device-specific protocols)。
而 Linux 上的 drivers 當中，幾乎全部都是走 evdev 的介面，包含前面列的三個。&lt;/p&gt;
&lt;p&gt;在 Linux 上，
Xorg 的 evdev driver (generic input driver) 提供基本的 keyboard、 mouse、lid switches、power switches 等功能，
經由 evdev 的 interface 到 /dev/input/eventN devices。&lt;/p&gt;
&lt;p&gt;至於 synaptics driver 呢，其實也是走 evdev 的 interface 來跟 kernel 溝通的。
在 Linux 上它不能跟硬體直接溝通，也不能弄 Synaptics™ hardware-specific。
synaptics driver 只是個從 evdev 分出去的 driver，加上了一些 touchpad 硬體要有的 features (例如: two-finger scrolling)，
在 Linux 上它比較像是個 &amp;quot;touchpad&amp;quot; module，在其他 non-Linux 平台上則可以使用 Synaptics protocol。&lt;/p&gt;
&lt;p&gt;而 joystick driver 的情況跟 synaptics driver 類似，走的也是 evdev 的 interface，
而不是 device-specific protocol。&lt;/p&gt;
&lt;p&gt;X 的概念只包含了 keyboards 和 pointers，而 pointers 則包含了 mice、touchpads、joysticks、wacom tablets ... etc。
X 另外還有 &lt;strong&gt;core&lt;/strong&gt; keyboard 和 pointer 的概念，預設所有的 device 都是送 core events 到 applications 的，
但是可以把特定 devices 設為 non-core。&lt;/p&gt;
&lt;p&gt;如果要收 non-core devices 的 events 的話，需要使用 XInput 或 XInput2 extensions。
XInput 提供 core-like 的 events (例如: DeviceMotionNotify、DeviceButtonPress)，
所以跟 core events 用起來類似，但是 setup 方式和大部分的 X extensions 不一樣。&lt;/p&gt;
</summary><category term="linux"></category><category term="udev"></category><category term="evdev"></category><category term="device"></category><category term="sysfs"></category><category term="Xorg"></category><category term="synaptics"></category></entry></feed>