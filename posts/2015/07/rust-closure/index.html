<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<title>Rust - Closure — Dv 名字很難念</title>
	<meta name="description" content="Title: Rust - Closure; Date: 2015-07-27; Author: wdv4758h">
	<meta name="author" content="wdv4758h">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
	<!--[if lt IE 9]>
		<script src="/theme/html5.js"></script>
		<![endif]-->
	<link href="/theme/css/ipython.css" rel="stylesheet">
	<link href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" rel="stylesheet">
	<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
	<link href="//maxcdn.bootstrapcdn.com/bootswatch/3.2.0/simplex/bootstrap.min.css" rel="stylesheet">
	<link href="/theme/css/local.css" rel="stylesheet">
	<link href="/theme/css/pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="/theme/tipuesearch/tipuesearch.css">
</head>

<body>
<div class="container">
	<div class="page-header">
		<h1>
            <a href="/">Dv 名字很難念</a>
			<br>
            <small>Aquí hay gato encerrado. </small>
            <form id="searchform" action="/search.html" onsubmit="return (this.elements['q'].value.length > 0)">
                    <input id="searchbox" type="text" name="q" size="12" placeholder="Search">
            </form>
        </h1>
        <a class="top-line-label" href="/about.html">About</a>
	</div>
	<div class="row">
        <div>
            <div class="row-fluid">
                <div class="col-md-8 col-md-offset-2">
<div class="article">

	<div class="text-center article-header">

		<h1 class="article-title">Rust - Closure</h1>
		<span>
			<h4>wdv4758h</h4>
		</span>
        <span>publish: <time datetime="2015-07-27T23:38:00+08:00">Mon 27 July 2015</time></span>

            <br>
            <span>update: <time datetime="2015-07-27 23:38:00+08:00">Mon 27 July 2015</time></span>

	</div>

	<div>
		Category:
		<span>
			<a href="/category/rust.html" rel="category">Rust</a>
		</span>
	</div>

	<div>
		Tags:
		<span>
			<a href="/tag/rust.html" rel="tag">Rust</a>
		</span>
		<span>
			<a href="/tag/closure.html" rel="tag">closure</a>
		</span>
		<span>
			<a href="/tag/trait.html" rel="tag">trait</a>
		</span>
		<span>
			<a href="/tag/move.html" rel="tag">move</a>
		</span>
	</div>

</div>
                </div>
            </div>
            <div class="row-fluid">
                <div class="col-md-2">
                </div>
                <div class="col-md-8">
	<div class="article-body"><hr class="docutils" />
<p><strong>tl;dr</strong></p>
<ul>
<li><p class="first">Rust's closures are syntax sugar for <tt class="docutils literal">trait</tt></p>
</li>
<li><dl class="first docutils">
<dt>default</dt>
<dd><ul class="first last simple">
<li>closure environment on <strong>stack</strong> (borrow)</li>
<li><strong>static</strong> dispatch</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>return from function</dt>
<dd><ul class="first last simple">
<li>closure environment on <strong>heap</strong> (use <tt class="docutils literal">Box</tt>)</li>
<li>use <tt class="docutils literal">move</tt> to create own stack frame</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>dynamic dispatch</dt>
<dd><ul class="first last simple">
<li>use reference</li>
</ul>
</dd>
</dl>
</li>
</ul>
<div class="highlight"><pre><span class="c-Doc">////////////////////////////////////////</span>

<span class="c1">// Syntax</span>

<span class="k">fn</span><span class="w">  </span><span class="n">plus_one_v1</span><span class="w">   </span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">}</span><span class="w">    </span><span class="c1">// function</span>
<span class="kd">let</span><span class="w"> </span><span class="n">plus_one_v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w">   </span><span class="c1">// closure</span>
<span class="kd">let</span><span class="w"> </span><span class="n">plus_one_v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">|</span><span class="w">          </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="p">;</span><span class="w">   </span><span class="c1">// closure</span>
<span class="kd">let</span><span class="w"> </span><span class="n">plus_one_v4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="w">      </span><span class="o">|</span><span class="w">          </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="p">;</span><span class="w">   </span><span class="c1">// closure</span>

<span class="c-Doc">////////////////////////////////////////</span>

<span class="c1">// dynamic dispatch (reference)</span>

<span class="k">fn</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">closure</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Fn</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">closure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">answer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="o">&amp;|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>

<span class="c-Doc">////////////////////////////////////////</span>

<span class="c1">// return closure from function</span>

<span class="k">fn</span><span class="w"> </span><span class="n">factory</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Fn</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">Box</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">move</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">num</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factory</span><span class="p">();</span><span class="w"></span>

<span class="c-Doc">////////////////////////////////////////</span>
</pre></div>
<hr class="docutils" />
<p>等待的時間總是無聊，
只好打開電腦研究點東西。</p>
<p>今天在 Slack 上聊天時，
聊到了在 Python 可以利用 function 回傳 function 來做一些特別的事，
對於一個 Python 使用者來說這件事很常遇到 (又看看 decorator)，
這時突然就連結到 Rust，
Rust 裡面也可以定義 local function，
那是否可以像 Python 一樣回傳出去使用？</p>
<p>於是，來翻翻 Rust 的 closure 吧 ~</p>
<hr class="docutils" />
<p>Rust 不只支援 named function，
還支援匿名函式，
當匿名函式裡有跟當時環境相關的變數時，
就稱為 closure，
以下就描述如何在 Rust 裡運用它。</p>
<div class="section" id="syntax">
<h2>Syntax</h2>
<p>Rust 的 closure 是用兩個 <tt class="docutils literal">|</tt> 把變數夾住，
後面接處理的 code，
可以用 <tt class="docutils literal">{}</tt> 把多個處理包起來 (Rust 的 <tt class="docutils literal">{}</tt> 是 expression)</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="n">plus_one</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">plus_one</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w"></span>

<span class="c-Doc">////////////////////////////////////////</span>

<span class="kd">let</span><span class="w"> </span><span class="n">plus_two</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">result</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">result</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">plus_two</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>

<span class="c-Doc">////////////////////////////////////////</span>

<span class="kd">let</span><span class="w"> </span><span class="n">plus_one</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="o">|</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">plus_one</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w"></span>

<span class="c-Doc">////////////////////////////////////////</span>

<span class="c1">// compare</span>

<span class="k">fn</span><span class="w">  </span><span class="n">plus_one_v1</span><span class="w">   </span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">plus_one_v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">plus_one_v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">|</span><span class="w">          </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">plus_one_v4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="w">      </span><span class="o">|</span><span class="w">          </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>這邊可以看到 Rust 的 closure 和一般 function 不同，
不需要寫明傳入和回傳的 type (但可以寫明)，
這設計是為了方便使用 (一般 function 要寫明是為了 documentation、type inference)。</p>
</div>
<div class="section" id="closure">
<h2>Closure 和外部變數</h2>
<p>先看一段範例 code：</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">plus_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">num</span><span class="p">;</span><span class="w"></span>

<span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="n">plus_num</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span><span class="w"></span>
</pre></div>
<p>這邊的 closure 有用到一個不是參數的變數 <tt class="docutils literal">num</tt> ，
他是靠外面的 <tt class="docutils literal">num</tt> 來取得資料，
更明確來說這個 closure 裡的 num 借 (borrow) 了外面 num 的 binding。</p>
<p>如果在那之後又更動了 num 這個變數，
則會在 compile time 時出錯：</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">plus_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">num</span><span class="p">;</span><span class="w"></span>

<span class="c1">// error</span>
<span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="c1">// error: cannot assign to `num` because it is borrowed</span>
<span class="c1">//     num = num + 1;</span>
<span class="c1">//     ^~~~~~~~~~~~~</span>
<span class="c1">// note: borrow of `num` occurs here</span>
<span class="c1">//     let plus_num = |x: i32| x + num;</span>
<span class="c1">//                 ^~~~~~~~~~~~~~~~</span>
</pre></div>
<p>但是可以用 <tt class="docutils literal">{}</tt> 把借用的區域包起來，
這樣超出這段範圍後就會停止借用：</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>

<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">plus_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">num</span><span class="p">;</span><span class="w"></span>

<span class="p">}</span><span class="w"> </span><span class="c1">// plus_num goes out of scope, borrow of num ends</span>

<span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>另外 Rust 的 closure 對於 non-copyable 的變數還會拿走 ownership、move 資源：</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">takes_nums</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">nums</span><span class="p">;</span><span class="w"></span>

<span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">nums</span><span class="p">);</span><span class="w"></span>


<span class="c1">// error: use of moved value: `nums` [E0382]</span>
<span class="c1">//     println!(&quot;{:?}&quot;, nums);</span>
<span class="c1">//                     ^~~~</span>
<span class="c1">// note: `nums` moved into closure environment here because it has type `collections::vec::Vec&lt;i32&gt;`, which is non-copyable</span>
<span class="c1">//     let takes_nums = || nums;</span>
<span class="c1">//                     ^~~~~~~</span>
</pre></div>
</div>
<div class="section" id="move-closures">
<h2>&quot;move&quot; closures</h2>
<p>對於不會自動觸發 ownership 轉移的情況，
我們可以使用 <tt class="docutils literal">move</tt> 來強制轉移
(注意的是這邊雖然叫 move，但是表示的是 closure 可以拿到 ownership，
不一定是 resourse 的 move，可能是 copy 一份)：</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>

<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">add_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="o">|</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// modify the original num</span>
<span class="w">    </span><span class="n">add_num</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="n">num</span><span class="p">);</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>

<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">add_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">move</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="o">|</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// modify a copy version of num</span>
<span class="w">    </span><span class="n">add_num</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">num</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>在沒有使用 <tt class="docutils literal">move</tt> 的情況下，
closure 會綁在建立這 closure 的 stack frame 上，
<tt class="docutils literal">move</tt> closure 則是 self-contained 的，
這裡也可以發現要回傳一個 non-move closure 是不行的 (因為綁在 function stack frame 上，回傳後會被清掉)。</p>
</div>
<div class="section" id="closure-implementation">
<h2>Closure implementation</h2>
<p>Rust closure 的實作和其他語言有點不同，
Rust 的 closure 是 trait 的 syntax sugar</p>
<ul class="simple">
<li><a class="reference external" href="https://doc.rust-lang.org/book/traits.html">Rust Book - Traits</a></li>
<li><a class="reference external" href="https://doc.rust-lang.org/book/trait-objects.html">Rust Book - Trait Objects</a></li>
</ul>
<p>在 Rust 裡，用 <tt class="docutils literal">()</tt> 來 call function 這件事是 overloadable 的，
我們可以用 trait 來 overload 這個 operator (有三種 trait 可以 overload)：</p>
<div class="highlight"><pre><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Fn</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">FnMut</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;rust-call&quot;</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">call</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="o">:</span><span class="w"> </span><span class="n">Args</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Self</span><span class="o">::</span><span class="n">Output</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">FnMut</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">FnOnce</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;rust-call&quot;</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">call_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="o">:</span><span class="w"> </span><span class="n">Args</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Self</span><span class="o">::</span><span class="n">Output</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">FnOnce</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="n">Output</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;rust-call&quot;</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">call_once</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="o">:</span><span class="w"> </span><span class="n">Args</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Self</span><span class="o">::</span><span class="n">Output</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>三種不同的情況，讓我們可以有良好的掌控性：</p>
<table border="1" class="table table-bordered docutils">
<colgroup>
<col width="42%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">trait</th>
<th class="head">self</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Fn</td>
<td>&amp;self</td>
</tr>
<tr><td>FnMut</td>
<td>&amp;mut self</td>
</tr>
<tr><td>FnOnce</td>
<td>self</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">|| {}</tt> 則是這三種情況的 syntax suger，
Rust 會為 closure 的外部變數生出 struct，
<tt class="docutils literal">impl</tt> 需要的 trait，然後使用它。</p>
</div>
<div class="section" id="closures-as-arguments">
<h2>closures as arguments</h2>
<p>到這邊我們得知 Rust 的 closure 其實就是 trait，
所以如何傳入和回傳 closure 就跟 trait 一樣 (這也表示我們可以選擇 static 或 dynamic dispatch)。</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">call_with_one</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">some_closure</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="w"></span>
<span class="w">    </span><span class="n">where</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Fn</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="n">some_closure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">answer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">call_with_one</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>

<span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">answer</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>這邊可以看到傳入的 type 為 <tt class="docutils literal">Fn(i32) <span class="pre">-&gt;</span> i32</tt> ，
Fn 就是個 trait，這邊寫明說會傳入 i32、回傳 i32，
這也就是我們 closure 需要的 type。</p>
<p>這邊一個重點是 Rust 的 closure 可以做 static dispatch，
在許多語言裡，closure 是 heap allocation 並且是 dynamic dispatch，
但是 Rust 可以做 stack allocation 和 static dispatch，
這很常被使用，尤其是在 iterator 那邊常常會傳入 closure 做篩選。</p>
<p>雖然 Rust 支援 static dispatch 的 closure，
但是想要使用 dynamic dispatch 還是可以的：</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">call_with_one</span><span class="p">(</span><span class="n">some_closure</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Fn</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">some_closure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">answer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">call_with_one</span><span class="p">(</span><span class="o">&amp;|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>

<span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">answer</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="returning-closures">
<h2>returning closures</h2>
<p>第一次失敗的嘗試：</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">factory</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">Fn</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="o">|</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factory</span><span class="p">();</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">answer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">answer</span><span class="p">);</span><span class="w"></span>

<span class="c1">// error: the trait `core::marker::Sized` is not implemented for the type</span>
<span class="c1">// `core::ops::Fn(i32) -&gt; collections::vec::Vec&lt;i32&gt;` [E0277]</span>
<span class="c1">//     f = factory();</span>
<span class="c1">//     ^</span>
<span class="c1">// note: `core::ops::Fn(i32) -&gt; collections::vec::Vec&lt;i32&gt;` does not have a</span>
<span class="c1">// constant size known at compile-time</span>
<span class="c1">//     f = factory();</span>
<span class="c1">//     ^</span>
<span class="c1">// error: the trait `core::marker::Sized` is not implemented for the type</span>
<span class="c1">// `core::ops::Fn(i32) -&gt; collections::vec::Vec&lt;i32&gt;` [E0277]</span>
<span class="c1">//     factory() -&gt; (Fn(i32) -&gt; Vec&lt;i32&gt;) {</span>
<span class="c1">//                  ^~~~~~~~~~~~~~~~~~~~~</span>
<span class="c1">// note: `core::ops::Fn(i32) -&gt; collections::vec::Vec&lt;i32&gt;` does not have a constant size known at compile-time</span>
<span class="c1">//     factory() -&gt; (Fn(i32) -&gt; Vec&lt;i32&gt;) {</span>
<span class="c1">//                  ^~~~~~~~~~~~~~~~~~~~~</span>
</pre></div>
<p>為了要從 function 回傳東西，Rust 需要知道 return type 的大小，
但是 <tt class="docutils literal">Fn</tt> 是一個 trait，它可以包含各種東西、是各種大小，
各種不同的 type 可以實作 <tt class="docutils literal">Fn</tt> ，
一個可以知道回傳大小的簡單方式就是用 reference (reference 的大小是已知的)</p>
<p>第二次失敗的嘗試：</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">factory</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="n">Fn</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="o">|</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factory</span><span class="p">();</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">answer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">answer</span><span class="p">);</span><span class="w"></span>

<span class="c1">// error: missing lifetime specifier [E0106]</span>
<span class="c1">//     fn factory() -&gt; &amp;(Fn(i32) -&gt; i32) {</span>
<span class="c1">//                     ^~~~~~~~~~~~~~~~~</span>
</pre></div>
<p>這次缺了 lifetime，我們用了 reference，
所以需要給個 lifetime，
這邊沒有參數，狀況很單純，使用 <tt class="docutils literal">'static</tt></p>
<p>第三次失敗的嘗試：</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">factory</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;static</span><span class="w"> </span><span class="p">(</span><span class="n">Fn</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">num</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factory</span><span class="p">();</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">answer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="n">answer</span><span class="p">);</span><span class="w"></span>


<span class="c1">// error: mismatched types:</span>
<span class="c1">// expected `&amp;&#39;static core::ops::Fn(i32) -&gt; i32`,</span>
<span class="c1">//     found `[closure &lt;anon&gt;:7:9: 7:20]`</span>
<span class="c1">// (expected &amp;-ptr,</span>
<span class="c1">//     found closure) [E0308]</span>
<span class="c1">//         |x| x + num</span>
<span class="c1">//         ^~~~~~~~~~~</span>
</pre></div>
<p>compiler 說他拿到的 type 是 <tt class="docutils literal">[closure <span class="pre">&lt;anon&gt;:7:9:</span> 7:20]</tt> ，
不是我們寫的 <tt class="docutils literal">&amp;'static Fn(i32) <span class="pre">-&gt;</span> i32</tt> ，
這是因為每個 closure 都是依照當時的 environment <tt class="docutils literal">struct</tt> 、 <tt class="docutils literal">Fn</tt> 實作，
這些 type 都是 anonymous 的，所以 Rust 把它視為 <tt class="docutils literal">closure &lt;anon&gt;</tt> 。
至於為何沒有實作 <tt class="docutils literal">&amp;'static Fn</tt> 則是因為 environment 是借來的，
而在這 case 中 environment 是 stack 上的變數，
所以 borrow 的 lifetime 等同於 stack frame 的 lifetime，
如果把 closure 回傳了，function stack frame 就會被清除，
closure 裡取到的就是不正確的值。</p>
<p>第四次失敗的嘗試：</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">factory</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Fn</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">Box</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">num</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factory</span><span class="p">();</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">answer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="n">answer</span><span class="p">);</span><span class="w"></span>

<span class="c1">// error: `num` does not live long enough</span>
<span class="c1">// Box::new(|x| x + num)</span>
<span class="c1">//          ^~~~~~~~~~~</span>
</pre></div>
<p>這次把 closure 丟到 heap 上了 (用 Box)，但是發現 num 還是取到 stack 上的值，
於是又再稍做修改。</p>
<p>成功：</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">factory</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Fn</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">Box</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">move</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">num</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factory</span><span class="p">();</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">answer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="n">answer</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>使用 <tt class="docutils literal">move</tt> 來為 closure 建立新的 stack frame來儲存一份使用到的外部變數，
利用 <tt class="docutils literal">Box</tt> 來把 closure 放到 heap 上，如此一來 size 變成已知，
離開原本建立的 stack frame 後也可以使用。</p>
</div>
<div class="section" id="reference">
<h2>Reference</h2>
<ul class="simple">
<li><a class="reference external" href="https://doc.rust-lang.org/book/closures.html">Rust Book - Closures</a></li>
</ul>
</div>
</div>

        <hr>
        <h2>Related Posts</h2>
        <ul>
            <li><a href="/posts/2015/07/rust-example-project-euler-1/">Rust Example - Project Euler #1 - Try Some Features in Simple Problem</a></li>
            <li><a href="/posts/2014/02/closure/">closure 概念</a></li>
        </ul>

	<hr>

	<h2>Comments</h2>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'wdv4758h-blog';
    var disqus_title = 'Rust - Closure';
	var disqus_identifier = 'posts/2015/07/rust-closure/';

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

                </div>
            </div>
		</div>
	</div> 	<!-- <hr> -->
</div> <!-- /container -->
<footer class="aw-footer bg-danger">
	<div class="container"> <!-- footer -->
		<div class="row">
			<div class="col-md-10 col-md-offset-1">
				<div class="row">
					<div class="col-md-3">
						<h4>Navigation</h4>
						<ul class="list-unstyled my-list-style">
							<li><a href="">Dv 名字很難念</a></li>
                            <li><a href="/about.html">About</a></li>
							<li><a href="/archives"><i class="fa fa-archive "></i> archive</a></li>
							<li><a href="/tags"><i class="fa fa-tags "></i> tags</a></li>
							<li><a href="/feeds/all.rss.xml"><i class="fa fa-rss "></i> rss</a></li>
						</ul>
					</div>
					<div class="col-md-3">
						<h4>Author</h4>
						<ul class="list-unstyled my-list-style">
							<li><a href="https://wdv4758h.github.com">Homepage</a></li>
							<li><a href="https://github.com/wdv4758h/">Github</a></li>
							<li><a href="https://plus.google.com/103751737509044116269/posts">Google+</a></li>
							<li><a href="https://www.facebook.com/wdv4758h">Facebook</a></li>
							<li><a href="https://www.linkedin.com/pub/chiu-hsiang-hsu/69/83/530">Linked-in</a></li>
						</ul>
					</div>
					<div class="col-md-3">
						<h4>Categories</h4>
						<ul class="list-unstyled my-list-style">
							<li><a href="/category/c++.html">C++ (1)</a></li>
							<li><a href="/category/compiler.html">Compiler (1)</a></li>
							<li><a href="/category/django.html">Django (2)</a></li>
							<li><a href="/category/functional.html">Functional (2)</a></li>
							<li><a href="/category/fuzzy.html">Fuzzy (1)</a></li>
							<li><a href="/category/gc.html">GC (1)</a></li>
							<li><a href="/category/html5.html">HTML5 (1)</a></li>
							<li><a href="/category/linux.html">Linux (3)</a></li>
							<li><a href="/category/misc.html">Misc (40)</a></li>
							<li><a href="/category/prolog.html">Prolog (1)</a></li>
							<li><a href="/category/python.html">Python (14)</a></li>
							<li><a href="/category/qemu.html">QEMU (1)</a></li>
							<li><a href="/category/rust.html">Rust (3)</a></li>
							<li><a href="/category/ted.html">TED (1)</a></li>
							<li><a href="/category/vim.html">Vim (3)</a></li>
						</ul>
					</div>
					<div class="col-md-3">
						<h4>Links</h4>
						<ul class="list-unstyled my-list-style">
							<li><a href="https://www.python.org/">Python</a></li>
							<li><a href="https://www.djangoproject.com/">Django</a></li>
						</ul>
					</div>
				</div>
			</div>
		</div>
	</div>
</footer>
<div class="container">
	<div class="row">
		<div class="col-md-12 text-center center-block aw-bottom">
			<p>&copy; wdv4758h 2014</p>
            <small>Arch Linux + Vim + reStructuredText + Pelican = Blog</small>
		</div>
	</div>
</div>
<!-- JavaScript -->
<script src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
<!-- search -->
<script type="text/javascript" src="/theme/tipuesearch/tipuesearch_set.js"></script>
<script type="text/javascript" src="/theme/tipuesearch/tipuesearch.min.js"></script>
<!------------>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
<script type="text/javascript">
jQuery(document).ready(function($) {
	$("div.collapseheader").click(function () {
		$header = $(this).children("span").first();
		$codearea = $(this).children(".input_area");
		$codearea.slideToggle(500, function () {
			$header.text(function () {
				return $codearea.is(":visible") ? "Collapse Code" : "Expand Code";
			});
		});
	});
});
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-42810012-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>